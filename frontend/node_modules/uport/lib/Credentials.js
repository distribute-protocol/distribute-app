'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _JWT = require('./JWT');

var _uportLite = require('uport-lite');

var _uportLite2 = _interopRequireDefault(_uportLite);

var _nets = require('nets');

var _nets2 = _interopRequireDefault(_nets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Credentials = function () {
  function Credentials() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Credentials);

    this.settings = settings;
    this.settings.networks = settings.networks ? configNetworks(settings.networks) : {};
    if (!this.settings.registry) {
      var registry = (0, _uportLite2.default)({ networks: this.settings.networks });
      this.settings.registry = function (address) {
        return new Promise(function (resolve, reject) {
          registry(address, function (error, profile) {
            if (error) return reject(error);
            resolve(profile);
          });
        });
      };
    }
  }

  // Create request token


  _createClass(Credentials, [{
    key: 'createRequest',
    value: function createRequest() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var payload = {};
      if (params.requested) {
        payload.requested = params.requested;
      }
      if (params.verified) {
        payload.verified = params.verified;
      }
      if (params.notifications) {
        payload.permissions = ['notifications'];
      }
      if (params.callbackUrl) {
        payload.callback = params.callbackUrl;
      }
      if (params.network_id) {
        payload.net = params.network_id;
      }
      return (0, _JWT.createJWT)(this.settings, _extends({}, payload, { type: 'shareReq' }));
    }

    // Receive response token from user and return data to promise

  }, {
    key: 'receive',
    value: function receive(token) {
      var _this = this;

      var callbackUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      return (0, _JWT.verifyJWT)(this.settings, token, callbackUrl).then(function (_ref) {
        var payload = _ref.payload,
            profile = _ref.profile;

        var credentials = _extends({}, profile, payload.own || {}, payload.capabilities && payload.capabilities.length === 1 ? { pushToken: payload.capabilities[0] } : {}, { address: payload.iss });
        if (payload.nad) {
          credentials.networkAddress = payload.nad;
        }
        if (payload.verified) {
          return Promise.all(payload.verified.map(function (token) {
            return (0, _JWT.verifyJWT)(_this.settings, token);
          })).then(function (verified) {
            return _extends({}, credentials, { verified: verified.map(function (v) {
                return _extends({}, v.payload, { jwt: v.jwt });
              }) });
          });
        } else {
          return credentials;
        }
      });
    }
  }, {
    key: 'push',
    value: function push(token, _ref2) {
      var url = _ref2.url;

      return new Promise(function (resolve, reject) {
        if (!token) {
          return reject(new Error('Missing push notification token'));
        }
        if (!url) {
          return reject(new Error('Missing payload url for sending to users device'));
        }

        (0, _nets2.default)({
          uri: 'https://pututu.uport.me/api/v1/sns',
          json: { url: url },
          method: 'POST',
          withCredentials: false,
          headers: {
            Authorization: 'Bearer ' + token
          }
        }, function (error, res, body) {
          if (error) return reject(error);
          if (res.statusCode === 200) {
            resolve(body);
          }
          if (res.statusCode === 403) {
            return reject(new Error('Error sending push notification to user: Invalid Token'));
          }
          reject(new Error('Error sending push notification to user: ' + res.statusCode + ' ' + body.toString()));
        });
      });
    }

    // Create attestation

  }, {
    key: 'attest',
    value: function attest(_ref3) {
      var sub = _ref3.sub,
          claim = _ref3.claim,
          exp = _ref3.exp;

      return (0, _JWT.createJWT)(this.settings, { sub: sub, claim: claim, exp: exp });
    }

    // Lookup public uport address of any user

  }, {
    key: 'lookup',
    value: function lookup(address) {
      return this.settings.registry(address);
    }
  }]);

  return Credentials;
}();

exports.default = Credentials;


var configNetworks = function configNetworks(nets) {
  Object.keys(nets).forEach(function (key) {
    var net = nets[key];
    if ((typeof net === 'undefined' ? 'undefined' : _typeof(net)) === 'object') {
      ['registry', 'rpcUrl'].forEach(function (key) {
        if (!net.hasOwnProperty(key)) throw new Error('Malformed network config object, object must have \'' + key + '\' key specified.');
      });
    } else {
      throw new Error('Network configuration object required');
    }
  });
  return nets;
};