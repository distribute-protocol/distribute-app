{"version":3,"file":"ipfs-mini.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap c297ac18c0fb87bccd4a","webpack:///lib/lib/XMLHttpRequest-browser.js","webpack:///lib/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"IPFS\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"IPFS\"] = factory();\n\telse\n\t\troot[\"IPFS\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c297ac18c0fb87bccd4a","\"use strict\";\n\nvar XMLHttpRequest = window.XMLHttpRequest; // eslint-disable-line\n\nmodule.exports = XMLHttpRequest;\n\n\n// WEBPACK FOOTER //\n// lib/lib/XMLHttpRequest-browser.js","'use strict';\n\nvar XMLHttpRequest = require('./lib/XMLHttpRequest');\n\nmodule.exports = IPFS;\n\n/**\n * The constructor object\n * @param {Object} `provider` the provider object\n * @return {Object} `ipfs` returns an IPFS instance\n * @throws if the `new` flag is not used\n */\nfunction IPFS(provider) {\n  if (!(this instanceof IPFS)) {\n    throw new Error('[ipfs-mini] IPFS instance must be instantiated with \"new\" flag (e.g. var ipfs = new IPFS(\"http://localhost:8545\");).');\n  }\n\n  var self = this;\n  self.setProvider(provider || {});\n}\n\n/**\n * Sets the provider of the IPFS instance\n * @param {Object} `provider` the provider object\n * @throws if the provider object is not an object\n */\nIPFS.prototype.setProvider = function setProvider(provider) {\n  if (typeof provider !== 'object') {\n    throw new Error('[ifpsjs] provider must be type Object, got \\'' + typeof provider + '\\'.');\n  }\n  var self = this;\n  var data = self.provider = Object.assign({\n    host: '127.0.0.1',\n    pinning: true,\n    port: '5001',\n    protocol: 'http',\n    base: '/api/v0' }, provider || {});\n  self.requestBase = String(data.protocol + '://' + data.host + ':' + data.port + data.base);\n};\n\n/**\n * Sends an async data packet to an IPFS node\n * @param {Object} `opts` the options object\n * @param {Function} `cb` the provider callback\n * @callback returns an error if any, or the data from IPFS\n */\nIPFS.prototype.sendAsync = function sendAsync(opts, cb) {\n  var self = this;\n  var request = new XMLHttpRequest(); // eslint-disable-line\n  var options = opts || {};\n  var callback = cb || function emptyCallback() {};\n\n  request.onreadystatechange = function () {\n    if (request.readyState === 4 && request.timeout !== 1) {\n      if (request.status !== 200) {\n        callback(new Error('[ipfs-mini] status ' + request.status + ': ' + request.responseText), null);\n      } else {\n        try {\n          callback(null, options.jsonParse ? JSON.parse(request.responseText) : request.responseText);\n        } catch (jsonError) {\n          callback(new Error('[ipfs-mini] while parsing data: \\'' + String(request.responseText) + '\\', error: ' + String(jsonError) + ' with provider: \\'' + self.requestBase + '\\'', null));\n        }\n      }\n    }\n  };\n\n  var pinningURI = self.provider.pinning && opts.uri === '/add' ? '?pin=true' : '';\n\n  if (options.payload) {\n    request.open('POST', '' + self.requestBase + opts.uri + pinningURI);\n  } else {\n    request.open('GET', '' + self.requestBase + opts.uri + pinningURI);\n  }\n\n  if (options.accept) {\n    request.setRequestHeader('accept', options.accept);\n  }\n\n  if (options.payload && options.boundary) {\n    request.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + options.boundary);\n    request.send(options.payload);\n  } else {\n    request.send();\n  }\n};\n\n/**\n * creates a boundary that isn't part of the payload\n */\nfunction createBoundary(data) {\n  while (true) {\n    var boundary = '----IPFSMini' + Math.random() * 100000 + '.' + Math.random() * 100000;\n    if (data.indexOf(boundary) === -1) {\n      return boundary;\n    }\n  }\n}\n\n/**\n * Add an string or buffer to IPFS\n * @param {String|Buffer} `input` a single string or buffer\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\nIPFS.prototype.add = function addData(input, callback) {\n  var data = typeof input === 'object' && input.isBuffer ? input.toString('binary') : input;\n  var boundary = createBoundary(data);\n  var payload = '--' + boundary + '\\r\\nContent-Disposition: form-data; name=\"path\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n' + data + '\\r\\n--' + boundary + '--';\n\n  var addCallback = function addCallback(err, result) {\n    return callback(err, !err ? result.Hash : null);\n  };\n  this.sendAsync({\n    jsonParse: true,\n    accept: 'application/json',\n    uri: '/add',\n    payload: payload, boundary: boundary\n  }, addCallback);\n};\n\n/**\n * Add an JSON object to IPFS\n * @param {Object} `jsonData` a single JSON object\n * @param {Function} `callback` a callback, with (error, ipfsHash String)\n * @callback {String} `ipfsHash` returns an IPFS hash string\n */\nIPFS.prototype.addJSON = function addJson(jsonData, callback) {\n  var self = this;\n  self.add(JSON.stringify(jsonData), callback);\n};\n\n/**\n * Get an object stat `/object/stat` for an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {Object} `stats` returns the stats object for that IPFS hash\n */\nIPFS.prototype.stat = function cat(ipfsHash, callback) {\n  var self = this;\n  self.sendAsync({ jsonParse: true, uri: '/object/stat/' + ipfsHash }, callback);\n};\n\n/**\n * Get the data from an IPFS hash\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, stats Object)\n * @callback {String} `data` returns the output data\n */\nIPFS.prototype.cat = function cat(ipfsHash, callback) {\n  var self = this;\n  self.sendAsync({ uri: '/cat/' + ipfsHash }, callback);\n};\n\n/**\n * Get the data from an IPFS hash that is a JSON object\n * @param {String} `ipfsHash` a single IPFS hash String\n * @param {Function} `callback` a callback, with (error, json Object)\n * @callback {Object} `data` returns the output data JSON object\n */\nIPFS.prototype.catJSON = function cat(ipfsHash, callback) {\n  var self = this;\n  self.cat(ipfsHash, function (jsonError, jsonResult) {\n    // eslint-disable-line\n    if (jsonError) {\n      return callback(jsonError, null);\n    }\n\n    try {\n      callback(null, JSON.parse(jsonResult));\n    } catch (jsonParseError) {\n      callback(jsonParseError, null);\n    }\n  });\n};\n\n\n// WEBPACK FOOTER //\n// lib/index.js"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;","sourceRoot":""}